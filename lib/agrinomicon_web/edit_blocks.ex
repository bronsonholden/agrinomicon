defmodule AgrinomiconWeb.EditBlocks do
  @moduledoc """
  Collection of functions for editing blocks via Mapbox.

  Updates, deletions, and insertions of blocks are broadcasting on the `blocks` pubsub topic.
  """
  alias Agrinomicon.Repo
  alias Agrinomicon.{Agency.Block, GIS, Production, Taxonomy}

  import Ecto.Query
  import Geo.PostGIS

  @doc """
  Create a new block for each feature in the given list. Returns the list of created blocks.

  Crop information for the created blocks is retrieved after the blocks are successfully created.
  """
  def create_blocks(features) do
    multi =
      Enum.reduce(features, Ecto.Multi.new(), fn feature, multi ->
        multi
        # this ID is generated by Mapbox, but we can use it to distinguish each insert op
        |> Ecto.Multi.insert(
          {:block, feature["id"]},
          Block.changeset(%Block{}, %{"feature" => %{"geometry" => feature["geometry"]}})
        )
      end)

    {:ok, results} = Repo.transaction(multi)

    new_blocks = Enum.map(results, fn {_name, block} -> block end)

    Phoenix.PubSub.broadcast(
      Agrinomicon.PubSub,
      "blocks",
      {:update_blocks, Enum.map(new_blocks, fn block -> block.id end)}
    )

    # queue up CDL jobs, which will send a follow-up pubsub message once updated
    new_blocks
    |> Enum.each(fn block ->
      AgrinomiconWeb.USDACDL.UpdateBlockTenures.new(%{"block_id" => block.id})
      |> Oban.insert()
    end)

    new_blocks
  end

  @doc """
  Update one or more blocks' features. Used when a single block is moved, has its
  coordinates changed, or when one or more features are moved together.

  ## Examples

      iex> update_feature_for_blocks(%{"b3e8...bcd2" => %{type: "Feature", ...}})
      %Block{...}
  """
  def update_feature_for_blocks(blocks) do
    multi =
      Enum.reduce(blocks, Ecto.Multi.new(), fn {block_id, feature}, multi ->
        multi
        |> Ecto.Multi.update(
          {:block, block_id},
          Block.changeset(%Block{id: block_id}, %{feature: feature})
        )
      end)

    {:ok, _} = Repo.transaction(multi)

    Phoenix.PubSub.broadcast(Agrinomicon.PubSub, "blocks", {:update_blocks, Map.keys(blocks)})
  end

  def delete_blocks(block_ids) do
    multi =
      Enum.reduce(block_ids, Ecto.Multi.new(), fn block_id, multi ->
        multi
        |> Ecto.Multi.delete(
          {:block, block_id},
          %Block{id: block_id}
        )
      end)

    {:ok, _} = Repo.transaction(multi)

    Phoenix.PubSub.broadcast(Agrinomicon.PubSub, "blocks", {:delete_blocks, block_ids})
  end

  def ordered_distributions_query() do
    from(d in Production.Distribution,
      left_join: c in Taxonomy.Classification,
      on: d.classification_id == c.id,
      order_by: [desc: d.coverage, desc: fragment("?[0]", c.common_names)],
      preload: :classification
    )
  end

  def ordered_tenures_query() do
    distributions = ordered_distributions_query()

    from(t in Production.Tenure,
      order_by: [desc: t.occupied_at],
      preload: [distributions: ^distributions]
    )
  end

  @doc """
  Returns a query for blocks near the given point with preloaded production
  information: tenures ordered in descending occupation date, with distributions
  ordered from greatest to least crop coverage, then by first common name.
  """
  def blocks_with_production_near_query(lng, lat) do
    x = String.to_float(lng)
    y = String.to_float(lat)

    tenures = ordered_tenures_query()

    from b in Block,
      join: f in GIS.Feature,
      on: b.feature_id == f.id,
      # TODO: Bounding box? Order by distance from camera + 1k limit?
      where: st_distance(st_centroid(f.geometry), st_point(^x, ^y)) < 0.3,
      preload: [
        :feature,
        tenures: ^tenures
      ]
  end

  @spec list_blocks_with_production_near(String.t(), String.t()) :: [%Block{}]
  def list_blocks_with_production_near(lng, lat) do
    blocks_with_production_near_query(lng, lat)
    |> Repo.all()
  end

  @spec list_blocks_with_production(list(String.t())) :: %Block{} | term() | nil
  def list_blocks_with_production(block_ids) do
    tenures = ordered_tenures_query()
    query = from b in Block, preload: [:feature, tenures: ^tenures]

    Repo.all(from b in query, where: b.id in ^block_ids)
  end
end
